!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=4)}([function(e,t,n){"use strict";function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}Object.defineProperty(t,"__esModule",{value:!0}),t.Vector=void 0;var i=function(){function e(t,n,r){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.x=t,this.y=n,this.z=r}var t,n,i;return t=e,i=[{key:"add",value:function(t,n){return new e(t.x+n.x,t.y+n.y,t.z+n.z)}}],(n=null)&&r(t.prototype,n),i&&r(t,i),e}();t.Vector=i},function(e,t){e.exports="attribute vec4 aPosition;\n\nvoid main() {\n  gl_Position = vec4(aPosition.xy, 0.0, 1.0);\n}"},function(e,t){e.exports="precision mediump float;\n\nuniform vec3 uLightAmb;\nuniform vec3 uLightDiff;\nuniform vec3 uSphereAmb;\nuniform vec3 uSphereDiff;\nuniform vec2 uResolution;\n\nstruct Light {\n  // Ambient and diffuse are vec3 because they need to hold values for RGB\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 position;\n  vec3 specular;\n};\n\nstruct Ray {\n  vec3 direction;\n  vec3 origin;\n};\n\nstruct Sphere {\n  vec3 center;\n  vec3 materialAmbient;\n  vec3 materialDiffuse;\n  vec3 materialSpecular;\n  float radius;\n};\n\nfloat raySphereIntersection(Ray ray, Sphere sphere) {\n  vec3 eyeToCtr = ray.origin - sphere.center;\n  float discriminant = pow( dot(eyeToCtr, ray.direction), 2.0) - ( dot(eyeToCtr, eyeToCtr) - pow(sphere.radius, 2.0));\n\n  if (discriminant < 0.0) {\n    return 10000.0;\n  }\n\n  float t0 = -dot(eyeToCtr, ray.direction) - sqrt(discriminant);\n  float t1 = -dot(eyeToCtr, ray.direction) + sqrt(discriminant);\n\n  if (t0 > 0.0 && t1 > 0.0){\n    if (t0 == t1) return t0;\n  }\n\n  return min(t0, t1);\n}\n\nvec3 lightAtPoint(vec3 point, Ray ray, Sphere sphere, Light light) {\n  // Phong Model:\n  // I = LambRamb + LdiffRdiff(L.N) + LspecRspec(E.R)e\n    // where I is intensity (returned value),\n    // L is incoming light intensity (determined by Light struct),\n    // R is reflection constant (determined by object surface)\n    // amb = ambient, diff = diffuse, spec = specular\n\n  vec3 normal = point - sphere.center;\n  vec3 N = normalize(normal);\n\n  vec3 lightDir = point - light.position;\n  vec3 L = normalize(lightDir);\n\n  float lambert = dot(N, -L);\n\n  vec3 Ia = light.ambient * sphere.materialAmbient;\n  vec3 Id = vec3(0.0);\n  vec3 Is = vec3(0.0);\n\n  // if (lambert > 0.0) {\n    Id = light.diffuse * sphere.materialDiffuse * lambert;\n\n    // E = direction to the eye = opposite of ray direction\n    vec3 E = -ray.direction;\n\n    // Calculate the reflection using in-built function, replacing\n    // 2 * dot(N, L)N - L\n    vec3 R = reflect(L, N);\n\n    float specular = pow( max(dot(R,E), 0.0), 80.0 );\n    Is = light.specular * sphere.materialSpecular * specular;\n  // }\n\n  vec3 intensity = Ia + Id + Is;\n  return intensity;\n}\n\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy / (uResolution - 0.5)) * 2.0 - 1.0;\n  vec4 color = vec4(vec3(0.0), 1.0);\n\n  Light light;\n  light.ambient = uLightAmb;\n  light.diffuse = uLightDiff;\n  light.position = vec3(1.0);\n  light.specular = vec3(1.0);\n\n  Ray ray;\n  ray.origin = vec3(0.0, 0.0, 1.0);\n  ray.direction = normalize(vec3(uv, -ray.origin.z));\n  \n  Sphere sphere;\n  sphere.center = vec3(0.0);\n  sphere.materialAmbient = uSphereAmb;\n  sphere.materialDiffuse = uSphereDiff;\n  // Shiny spot will be white\n  sphere.materialSpecular = vec3(1.0);\n  sphere.radius = 0.5;\n\n  float intersect = raySphereIntersection(ray, sphere);\n  vec3 hitPoint = ray.origin + intersect * ray.direction;\n  if (intersect < 10000.0) {\n    vec3 rgb = lightAtPoint(hitPoint, ray, sphere, light);\n    color = vec4(rgb, 1.0);\n  }\n\n  gl_FragColor = color;\n}"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Raytracer=void 0;var r=o(n(2)),i=o(n(1)),a=n(0);function o(e){return e&&e.__esModule?e:{default:e}}function c(e){return function(e){if(Array.isArray(e))return e}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},r=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(n).filter(function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.forEach(function(t){l(e,t,n[t])})}return e}function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var f={uLightAmb:{defaultValue:new a.Vector(12.75,12.75,12.75),label:"Light: Ambient",uniformName:"uLightAmb"},uLightDiff:{defaultValue:new a.Vector(127.5,204,25.1),label:"Light: Diffuse",uniformName:"uLightDiff"},uSphereAmb:{defaultValue:new a.Vector(204,204,255),label:"Sphere: Ambient",uniformName:"uSphereAmb"},uSphereDiff:{defaultValue:new a.Vector(255,255,255),label:"Sphere: Diffuse",uniformName:"uSphereDiff"}},h=function(){function e(t){var n=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e);var r=t.getContext("webgl");if(!r)throw new Error("WebGL is not available");if(this.canvas=t,this.gl=r,this.program=this.createProgram(),!this.program)throw new Error("WebGL program was not created");this.positionAttributeLocation=this.gl.getAttribLocation(this.program,"aPosition"),this.resolutionUniformLocation=this.gl.getUniformLocation(this.program,"uResolution"),this.uniforms=Object.keys(f).reduce(function(e,t){var r=f[t];return e[r.uniformName]=u({},r,{location:n.gl.getUniformLocation(n.program,r.uniformName),value:r.defaultValue}),e},{}),this.buildControls(),this.render()}var t,n,a;return t=e,(n=[{key:"createProgram",value:function(){var e=this.gl,t=this.createShader(e.VERTEX_SHADER,i.default),n=this.createShader(e.FRAGMENT_SHADER,r.default),a=e.createProgram();return e.attachShader(a,t),e.attachShader(a,n),e.linkProgram(a),e.getProgramParameter(a,e.LINK_STATUS)?a:(e.deleteProgram(a),null)}},{key:"createShader",value:function(e,t){var n=this.gl,r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),n.getShaderParameter(r,n.COMPILE_STATUS)?r:(n.deleteShader(r),null)}},{key:"initBuffers",value:function(){var e=this.gl,t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t);return e.bufferData(e.ARRAY_BUFFER,new Float32Array([1,1,-1,1,1,-1,-1,-1]),e.STATIC_DRAW),{position:t}}},{key:"resizeCanvas",value:function(){var e=this.gl,t=window.devicePixelRatio,n=Math.floor(e.canvas.clientWidth*t),r=Math.floor(e.canvas.clientHeight*t);e.canvas.width===n&&e.canvas.height===r||(e.canvas.width=n,e.canvas.height=r),e.viewport(0,0,e.canvas.width,e.canvas.height)}},{key:"render",value:function(){var e=this,t=this.gl,n=this.program;if(n){t.useProgram(n);var r=this.initBuffers();this.resizeCanvas(),t.clearColor(0,0,0,1),t.clear(t.COLOR_BUFFER_BIT),t.enableVertexAttribArray(this.positionAttributeLocation),t.bindBuffer(t.ARRAY_BUFFER,r.position),t.vertexAttribPointer(this.positionAttributeLocation,2,t.FLOAT,!1,0,0),t.uniform2f(this.resolutionUniformLocation,t.canvas.width,t.canvas.height),Object.keys(this.uniforms).forEach(function(n){var r=e.uniforms[n];if(r&&r.location){var i=r.value||r.defaultValue;t.uniform3f(r.location,i.x/255,i.y/255,i.z/255)}}),t.drawArrays(t.TRIANGLE_STRIP,0,4)}}},{key:"buildControls",value:function(){var e=this,t=document.getElementById("controls");t&&Object.keys(this.uniforms).forEach(function(n){var r=f[n],i=document.createElement("fieldset"),a=document.createElement("legend");a.innerText=r.label,i.appendChild(a);var o=r.value||r.defaultValue,c=o.x,u=o.y,l=o.z;i.appendChild(e.createRangeInput("".concat(r.uniformName,"-x"),c,"Red")),i.appendChild(e.createRangeInput("".concat(r.uniformName,"-y"),u,"Green")),i.appendChild(e.createRangeInput("".concat(r.uniformName,"-z"),l,"Blue")),t.appendChild(i)})}},{key:"createRangeInput",value:function(e,t,n){var r=document.createElement("label");r.htmlFor=e;var i=document.createElement("span");i.innerText=n,r.appendChild(i);var a=document.createElement("input");return a.id=e,a.max="255",a.min="0",a.name=e,a.type="range",a.value=t.toString(),a.addEventListener("change",this.onSliderChange.bind(this)),r.appendChild(a),r}},{key:"onSliderChange",value:function(e){var t=e.target,n=t.id,r=t.value,i=c(n.split("-")),a=i[0],o=i[1],s=(i.slice(2),this.uniforms[a]);if(s&&s.location){var f=s.value||s.defaultValue,h=u({},s,{value:f=u({},f,l({},o,r))});this.uniforms=u({},this.uniforms,l({},s.uniformName,h)),this.gl.uniform3f(s.location,+f.x/255,+f.y/255,+f.z/255),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}}}])&&s(t.prototype,n),a&&s(t,a),e}();t.Raytracer=h},function(e,t,n){"use strict";var r=n(3);document.addEventListener("DOMContentLoaded",function(){var e=document.getElementById("canvas");if(e){var t=new r.Raytracer(e);console.log(t)}else console.log("No canvas found")})}]);